package Lessons.Lesson8.NonAccess_Modifier_final;

public class Non_Access_Modifier { //все это касаеться примитивных переменных:

    //Существуют  3 вида Non-access Modifier: final, static, abstract.

    //Final Non-access Modifier может относится: к variables, method , class
    // * Из переменных final делает константу. То есть значение этой переменной никогда не будет меняться.

    //Non-access Modifier и access Modifier можно менять местами,разницы нет,самое главное,что бы они шли до типа данных.
    final public int a = 5;
    public final int b = 15;
    public static void main(String[] args) {
        Non_Access_Modifier t = new Non_Access_Modifier();
//        t.a = a*2;                    где final там переменную нельзя менять. Read only , при попытки изменить переменнкю
        System.out.println(t.a);     //компилятор сразу выдаст ошибку.

        //Так же у final переменных нет дефолт значения:
//        final int n;  копилятор при попытки созданить дефолт значения с контроллером final сразу выдает ошибку
//        System.out.println(n);
    }
}
        //Однако можно сделать следуюим образом:
class otem {
            final int g;
            static final int j=7;    //statik final int  нельзя использовать в конструкторе ,как просто final int
            otem() {
                g = 10;
            }

            otem(boolean t) {
                g = 15;
            }
            //мы можем создать дефолт значения для того,что бы имзенить это значение в конструкторе. Иначе его ни как не поменять.
            //таким образом можно манипулировать константами с помощью конструкторов. Но при вызове конструктора и создании
            //объекта значение константы уже нельзя будет изменить. То есть при вызове нашего первого конструктора
            // g = 10 - всегда и не изменно, а при втором g = 15. Переменные final всегда нужно определять значения,
            //они так же как и local переменная ( переменные внутри метода) не имеют дефолт значений.

     //Но если будет static final тогда это правило не действует:

     //static final int j;
   //  otemm(boolean t) {
 //        j = 15;   //так сделать нельзя будет
   //  }
            //Но мы можем сразу вызвать её не создавая объект:
     public static void main(String[] args) {
         System.out.println(j); //
     }

     //Если переменная не статик мы можем присваивать значение в конструкторе,инстанс переменной.
            //если же статик в конструкторе нельзя,нужно сразу определять ей значение при создании переменной,а не в
            //каждом конструкторе.

            public void abc(short s) {
                final byte b = 10; //переменная внутри метода называеться local ,её не видно не внутри метода .
//        b=15; если внутри метода мы уже присвоили один раз final значения, то даже в том же методе мы его уже не можем
                //изменить
                System.out.println(b);
            }

                public void cba(double u) {
                    final int y; //если и создаем внутри метода дефолт значения final,то сразу же присваиваем этой константе
                    y = 15;    //какое-то значение,иначе будет ошибка компилятора.
                    System.out.println(y); //такой же метод в main вызывает ошибку
                }
                //               final int yu;  //но таким же методом не получится сделать вне метода,конструктора
                //               yu = 10; //так как константе нужно сразу определять значение.
                //               System.out.println(yu);

            public void abcd(final short s) { //можно создавать и параметры метода/конструктора final
//                final byte s = 10;     но при указании такого параметра изменить его уже будет нельзя,даже внутри того
                  //же метода
            }
}







